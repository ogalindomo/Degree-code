package HW4;
import java.util.Random;
/**
 * Class that implements the mid-difficulty AI and implements the contract of the class AI.
 *
 * @author Oscar Galindo, Mario Delgado
 *
 */
public class MediumAI implements AI
{
    /** Instance of the board model that the game is currently using */
    private Board board;

    /** X component of the coordinate generated by the execution */
    private int x;

    /** Y component of the coordinate generated by the execution */
    private int y;

    /** Change of the x coordinates in the execution */
    private int delta_x;

    /** Change of the y coordinates in the execution */
    private int delta_y;

    /** Integer that represents biggest number of disks in a space of 5 coordinates. */
    private int highestInChunk;

    /** Reference to the array that holds */
    private boolean playerArr [][];

    /** Reference of the board */
    private boolean aiArr[][];

    /**
     *  Constructor of the objects Medium AI.
     */
    public MediumAI (Board board)
    {
        this.board = board;
        highestInChunk = 0;
    }

    /**
     *  Method that executes the necessary steps to make a move.
     */
    public void makeMove()
    {
        playerArr = board.aiAnalysisArray();
        aiArr = board.aiArray();
        getCoordinates();
        board.addDisk(x,y);
        while(board.getStatus() == 2) //This loop is present because the first step is a random selection of a starting point, it could be wrong and a set of coordinates is needed.
        {
            getCoordinates();
            board.addDisk(x,y);
        }
    }

    /**
     *  Decides the coordinates to be played either deffensively or offensively.
     */
    public void getCoordinates()
    {
        if(possibleFive(playerArr,aiArr)) //Checks whether if the player has option of winning and if so it blocks said option.
        {
            setCoordinates(playerArr);
        }
        else //If the player does not have an option of winning then the AI decides where to place its disk.
        {
            if(board.getNumberOfDisks() < 2) // The first movement of the AI is a random selection of a coordintate from where to start.
            {
                Random rand = new Random();
                int sizeLimit = board.size();
                this.x = rand.nextInt(sizeLimit - 1);
                this.y = rand.nextInt(sizeLimit - 1);
            }
            else //After the first two movements the AI implements this options to find the best coordinate to construct a connect five.
            {
                possibleFive(aiArr, playerArr);
                setCoordinates(aiArr);
            }
        }
    }

    /**
     *  Indicates if either the player or the AI have a possibility to have a connect five.
     *  @param boolean analyzed[][] (Array of the entity, user/AI that will be analyzed).
     *  @param boolean enemy[][] (Array of the opposite entity).
     *  @return boolean possible an indiciation of whether the analyzed entity (AI or user) has relevant options of winning.
     */
    private boolean possibleFive(boolean analyzed[][], boolean enemy[][])
    {
       boolean possible = false;
       boolean prov [] = new boolean[5];
       highestInChunk = 0;
        for(int coord_x = 0; coord_x < board.size(); coord_x++)//Loop that goes through each possible x coordinate
       {
           for(int coord_y = 0; coord_y < board.size(); coord_y++)//Loop that goes through each possible y coordinate
           {
               //Each of the following for loops represents a direction to traverse and check for a possible winning combination, these loops check the diagonal, horizontal, and vertical direction.
               if(analyzed[coord_x][coord_y])
               {
                   if(permitted(coord_x + 4, coord_y))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y]; x++, i++)
                           prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, 1, 0, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x - 4, coord_y))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y]; x--, i++)
                           prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, -1, 0, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x,coord_y+4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y]; y++, i++)
                           prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, 0, 1, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x, coord_y - 4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y]; y--, i++)
                           prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, 0, -1, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x + 4, coord_y +4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y]; x++, y++, i++)
                           prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, 1, 1, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x - 4, coord_y +4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y] ; x--, y++, i++)
                          prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, -1, 1, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x - 4, coord_y - 4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y] ; x--, y--, i++)
                          prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, -1, -1, prov) && !possible)
                              possible = true;
                   }

                   if(permitted(coord_x + 4, coord_y - 4))
                   {
                       int i = 0;
                       for(int x = coord_x, y = coord_y; i < prov.length && !enemy[x][y] ; x++, y--, i++)
                          prov[i] = analyzed[x][y];
                       if(i == 5)
                           if(decision(coord_x, coord_y, 1, -1, prov) && !possible)
                              possible = true;
                   }
               }
           }
       }
       return possible;
    }

    /**
     *  Analyses every chunk of the board extracted in possibleFive method.
     *  @see possibleFive
     *  @param int origin_x first x coordinate of the chunk extracted.
     *  @param int origin_y first y coordinate of the chunk extracted.
     *  @param int delta_x numerical change in the axis of the x coordinate.
     *  @param int delta_y numerical change in the axis of the y coordinate.
     *  @param boolean prov[] reference to the boolean array, chunk generated in possibleFive.
     *  @return boolean indicating if this chunk of the board contains a possibility to connect five exists.
     */
    private boolean decision (int orig_x, int orig_y, int delta_x, int delta_y, boolean prov[])
    {
        int count = 0;
        for(int i = 0, x = orig_x, y = orig_y; i < prov.length; i++, x += delta_x, y += delta_y)
        {
            if(prov[i])
                count += 1;
        }
        if(count > highestInChunk)
        {
            highestInChunk = count;
            x = orig_x;
            y = orig_y;
            this.delta_x = delta_x;
            this.delta_y = delta_y;
        }
        if(count > 2)
            return true;
        return false;
    }

    /**
     *  Sets the coordinates to be played/used based on every execution.
     *  @param boolean entiyArr[][] (Reference to the array that the execution is analyzing).
     */
    private void setCoordinates(boolean entityArr[][])
    {
        boolean found = false;
        for(int i = 0, x = this.x, y = this.y; i < 5; i++, x += delta_x, y += delta_y)
        {
            if(!entityArr[x][y] && !found)
            {
                this.x = x;
                this.y = y;
                found = true;
            }
        }
    }

    /** Reports if the position being checked by the win method actually
     *  exists within the array of the player whose turn it is.
     *  @param x x input
     *  @param y y input
     *  @return boolean that indiciates if the coordinate that will be accessed by the win method actually exists.
     */
    private boolean permitted(int x, int y)
    {
       int size = board.size();
       if(x >= 0 && x < size && y >= 0 && y < size)
         return true;
       return false;
    }

    /**
     *  Setter for updating the board instance being currently used in execution.
     *  @param Board board (model of the game).
     */
    public void setBoard(Board board)
    {
       this.board = board;
    }
}
